
# Generated by CodiumAI

# Dependencies:
# pip install pytest-mock
from ExileCraft.ExileCraft.modules.db import get_base_item_stats

"""
Code Analysis

Objective:
The objective of the 'get_base_item_stats' function is to retrieve the statistics of a base item from a SQLite database given its name. The function returns a tuple containing various statistics of the base item.

Inputs:
- base_item_name (str): The name of the base item to retrieve statistics for.

Flow:
1. Connect to the 'exilecraft.db' database using the sqlite3 module.
2. Create a cursor object to execute SQL queries.
3. Execute a parameterized SQL query to retrieve the statistics of the base item with the given name from the 'base_items' table.
4. Fetch the result of the query and store it in the 'item_stats' variable.
5. Close the database connection.
6. Return the 'item_stats' tuple.

Outputs:
- tuple: Contains the following base item statistics:
    - drop_level
    - implicits
    - name
    - properties_attack_time
    - properties_critical_strike_chance
    - properties_physical_damage_min
    - properties_physical_damage_max
    - requirements_strength
    - requirements_dexterity
    - requirements_intelligence
    - requirements_level
    - properties_armour
    - properties_evasion
    - properties_energy_shield
    - properties_movement_speed
    - properties_block
    - properties_range

Additional aspects:
- The function uses parameterized queries to prevent SQL injection attacks.
- The function assumes that the 'base_items' table exists in the 'exilecraft.db' database.
"""


class TestGetBaseItemStats:
    #  Tests that the function returns the correct statistics for a valid base item name. Tags: [happy path]
    SQLITE3_CONNECT = 'sqlite3.connect'
    BASE_ITEM_NAME = 'Shabby Jerkin'

    def test_happy_path_retrieving_valid_base_item_stats(self, mocker):
        # Mock the sqlite3 module
        mock_conn = mocker.patch(self.SQLITE3_CONNECT)
        mock_cursor = mock_conn.return_value.cursor.return_value
        mock_cursor.fetchone.return_value = (1, 'implicit', self.BASE_ITEM_NAME, 1.5, 5, 1, 2, 10, 10, 10, 1, 20, 30, 40, 5, 10, 2)

        # Call the function with a valid base item name
        result = get_base_item_stats(self.BASE_ITEM_NAME)

        # Assert that the correct statistics are returned
        assert result == (1, 'implicit', 'Shabby Jerkin', 1.5, 5, 1, 2, 10, 10, 10, 1, 20, 30, 40, 5, 10, 2)

    # Tests that the function returns the correct statistics when retrieving statistics for a base item with only one
    # property. Tags: [edge case]
    def test_edge_case_retrieving_base_item_with_one_property(self, mocker):
        # Mock the sqlite3 module
        mock_conn = mocker.patch(self.SQLITE3_CONNECT)
        mock_cursor = mock_conn.return_value.cursor.return_value
        mock_cursor.fetchone.return_value = (1, 'implicit', 'Base Item With One Property', None, None, 1, None, None, None, None, None, None, None, None, None, None, None)

        # Call the function with a base item with only one property
        base_item_name = 'Base Item With One Property'
        result = get_base_item_stats(base_item_name)

        # Assert that the correct statistics are returned
        assert result == (1, 'implicit', 'Base Item With One Property', None, None, 1, None, None, None, None, None, None, None, None, None, None, None)

    #  Tests that the function handles invalid input gracefully by returning None. Tags: [general behavior]
    def test_general_behavior_handling_invalid_input(self, mocker):
        # Mock the sqlite3 module
        mock_conn = mocker.patch(self.SQLITE3_CONNECT)
        mock_cursor = mock_conn.return_value.cursor.return_value
        mock_cursor.fetchone.return_value = None

        # Call the function with an invalid input
        base_item_name = 'Invalid Base Item Name'
        result = get_base_item_stats(base_item_name)

        # Assert that None is returned
        assert result is None

    # Tests that the function returns the correct statistics when retrieving statistics for a base item with the
    # minimum possible values for each property. Tags: [edge case]
    def test_edge_case_retrieving_base_item_with_minimum_values(self, mocker):
        # Mock the sqlite3 module
        mock_conn = mocker.patch(self.SQLITE3_CONNECT)
        mock_cursor = mock_conn.return_value.cursor.return_value
        mock_cursor.fetchone.return_value = (1, 'implicit', 'Base Item With Minimum Values', 0.1, 0.1, 0.1, 0.1, 0, 0, 0, 0, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1)

        # Call the function with a base item with minimum values for each property
        base_item_name = 'Base Item With Minimum Values'
        result = get_base_item_stats(base_item_name)

        # Assert that the correct statistics are returned
        assert result == (1, 'implicit', 'Base Item With Minimum Values', 0.1, 0.1, 0.1, 0.1, 0, 0, 0, 0, 0.1, 0.1, 0.1, 0.1, 0.1, 0.1)

    # Tests that the function returns the correct statistics when retrieving statistics for a base item with the
    # maximum possible values for each property. Tags: [edge case]
    def test_edge_case_retrieving_base_item_with_maximum_values(self, mocker):
        # Mock the sqlite3 module
        mock_conn = mocker.patch(self.SQLITE3_CONNECT)
        mock_cursor = mock_conn.return_value.cursor.return_value
        mock_cursor.fetchone.return_value = (100, 'implicit', 'Base Item With Maximum Values', 100.0, 100.0, 100.0, 100.0, 100, 100, 100, 100, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0)

        # Call the function with a base item with maximum values for each property
        base_item_name = 'Base Item With Maximum Values'
        result = get_base_item_stats(base_item_name)

        # Assert that the correct statistics are returned
        assert result == (100, 'implicit', 'Base Item With Maximum Values', 100.0, 100.0, 100.0, 100.0, 100, 100, 100, 100, 100.0, 100.0, 100.0, 100.0, 100.0, 100.0)
